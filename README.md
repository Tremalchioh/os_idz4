# Куртаев Альберт Фанисович. БПИ-227.

# ИДЗ №4. Вариант 8.

## 4-5 Баллов.
Разработать клиент-серверное приложение, в котором сервер и клиенты независимо друг от друга отображают только ту информацию, которая поступает им во время обмена. Требуется смоделировать поведение обедающих философов, синхронизируемых посредством сервера, который фиксирует состояние стола и организует взаимодействие с философами. При запуске программ IP-адреса и порты задаются в командной строке.

1. **Создание серверной программы**:
   - Сервер управляет состоянием вилок.
   - Обрабатывает запросы философов на получение и освобождение вилок.
   - Отправляет философам результаты их запросов.

2. **Создание клиентской программы для философов**:
   - Философы запрашивают вилки у сервера для приема пищи.
   - Сообщают серверу об освобождении вилок после приема пищи.
   - Периодически думают и едят, время этих действий задается случайным образом.
   - Отображают в консоли результаты своих действий (размышляют, едят).

3. **Взаимодействие между сервером и клиентами**:
   - Использование сокетов TCP для связи между сервером и клиентами.
   - Сервер прослушивает входящие подключения на заданном порту.
   - Клиенты подключаются к серверу и отправляют запросы.

## Компиляция и запуск программы.

### Используемый компилятор.

Для компиляции программы использовался компилятор Clang.

### Компиляция серверной программы.

```sh 
clang++ -std=c++11 -o server server.cpp -pthread
```
### Компиляция клиентской программы.

```sh
clang++ -std=c++11 -o philosopher philosopher.cpp -pthread
```

### Запуск серверной программы в отдельном терминале.

```sh
./server
```

### Запуск клиентских программ для философов в другом терминале.
#### <server_ip> Выбираем, какой нужен. Я выбирал адрес локальной сети.
```sh
./philosopher <server_ip> 0 & 
./philosopher <server_ip> 1 &
./philosopher <server_ip> 2 &
./philosopher <server_ip> 3 &
./philosopher <server_ip> 4 &
```


### Завершение программ.
#### Завершение программ выполняем данной командой, вставив нужный <PID>, который выводится в консоль после каждого запуска новой программы.
```sh
kill -9 <PID>
``` 
Например:
```sh
./philosopher 172.19.174.18 1 &
[1] 73289
```
Завершаем программу
```sh
kill -9 73289
```
Также необходимо найти PID процесса сервера командой
```
ps aux | grep server
```
и таким же способом его завершить.
### Место для скриншотов.

![Вывод сервера](OS_IDZ$/screenshots/server.png)

![Вывод клиентов](OS_IDZ$/screenshots/philosopher.png)





## 6-7-8 Баллов.

## Проблемы с использованием UDP

Изначально я пытался реализовать взаимодействие между сервером и монитором через протокол UDP. Однако я столкнулся с несколькими проблемами:
1. Ненадежность доставки сообщений: сообщения могли теряться или приходить в неправильном порядке.
2. Ошибки при получении сообщений: часто возникали ошибки, связанные с приемом данных, что приводило к непредсказуемому поведению системы.
3. Отсутствие подтверждений доставки сообщений, что затрудняло синхронизацию между сервером и монитором.

Из-за этих проблем я решил перейти на использование протокола TCP для мониторов, который обеспечивает надежное и упорядоченное соединение. Это позволил стабильно передавать состояние философов от сервера к мониторам и избегать проблем, связанных с потерей данных.



Разработать клиент-серверное приложение, в котором сервер и клиенты независимо друг от друга отображают только ту информацию, которая поступает им во время обмена. Требуется смоделировать поведение обедающих философов, синхронизируемых посредством сервера, который фиксирует состояние стола и организует взаимодействие с философами. При запуске программ IP-адреса и порты задаются в командной строке.

Необходимо также разработать отдельную клиентскую программу, подключаемую к серверу, которая предназначена для отображения комплексной информации о выполнении приложения в целом.


1. **Создание серверной программы**:
   - Сервер управляет состоянием вилок.
   - Обрабатывает запросы философов на получение и освобождение вилок.
   - Отправляет философам результаты их запросов.
   - Отправляет текущие состояния системы клиентам-мониторам.

2. **Создание клиентской программы для философов**:
   - Философы запрашивают вилки у сервера для приема пищи.
   - Сообщают серверу об освобождении вилок после приема пищи.
   - Периодически думают и едят, время этих действий задается случайным образом.
   - Отображают в консоли результаты своих действий (размышляют, едят).

3. **Создание клиентской программы для мониторинга**:
   - Подключается к серверу и получает информацию о текущем состоянии системы.
   - Отображает полученную информацию в реальном времени.

4. **Взаимодействие между сервером и клиентами**:
   - Использование сокетов TCP для связи между сервером и клиентами.
   - Сервер прослушивает входящие подключения на заданном порту.
   - Клиенты подключаются к серверу и отправляют запросы.
   - Мониторы подключаются к серверу и получают информацию о текущем состоянии системы.


## Компиляция и запуск программы.

### Используемый компилятор.

Для компиляции программы использовался компилятор Clang.

### Компиляция серверной программы.

```sh 
clang++ -std=c++11 -o server server.cpp -pthread
```
### Компиляция клиентской программы.

```sh
clang++ -std=c++11 -o philosopher philosopher.cpp -pthread
```

### Компиляция монитора.

```sh
clang++ -std=c++11 -o monitor monitor.cpp -pthread
```


### Запуск серверной программы в отдельном терминале.

```sh
./server
```

### Запуск клиентских программ для философов в другом терминале.
#### <server_ip> Выбираем, какой нужен. Я выбирал адрес локальной сети.
```sh
./philosopher <server_ip> 0 & 
./philosopher <server_ip> 1 &
./philosopher <server_ip> 2 &
./philosopher <server_ip> 3 &
./philosopher <server_ip> 4 &
```

### Подключение монитора для философов в третьем терминале.
```sh
./monitor <server_ip>
```

### Завершение программ.
#### Завершение программ выполняем данной командой, вставив нужный <PID>, который выводится в консоль после каждого запуска новой программы.
```sh
kill -9 <PID>
``` 
Например:
```sh
./philosopher 172.19.174.18 1 &
[1] 73289
```
Завершаем программу
```sh
kill -9 73289
```
Также необходимо найти PID процесса сервера командой
```
ps aux | grep server
```
и таким же способом его завершить.

### Место для скриншотов.

![Вывод сервера](OS_IDZ$/screenshots/server.png)

![Вывод клиентов](OS_IDZ$/screenshots/philosopher.png)

![Вывод одного из мониторов](OS_IDZ$/screenshots/monitor.png)


## 10 Баллов.
Разработать клиент-серверное приложение, в котором сервер и клиенты независимо друг от друга отображают только ту информацию, которая поступает им во время обмена. Требуется смоделировать поведение обедающих философов, синхронизируемых посредством сервера, который фиксирует состояние стола и организует взаимодействие с философами. При запуске программ IP-адреса и порты задаются в командной строке.

Необходимо также разработать отдельную клиентскую программу, подключаемую к серверу, которая предназначена для отображения комплексной информации о выполнении приложения в целом. Клиентов-наблюдателей можно подключать и отключать в динамическом режиме без нарушения работы всего приложения.

Также при завершении работы сервера должно происходить корректное завершение работы всех подключенных клиентов.

## Алгоритм выполнения задачи.

1. **Создание серверной программы**:
   - Сервер управляет состоянием вилок.
   - Обрабатывает запросы философов на получение и освобождение вилок.
   - Отправляет философам результаты их запросов.
   - Отправляет текущие состояния системы клиентам-мониторам.
   - Уведомляет всех клиентов о завершении работы при остановке сервера.

2. **Создание клиентской программы для философов**:
   - Философы запрашивают вилки у сервера для приема пищи.
   - Сообщают серверу об освобождении вилок после приема пищи.
   - Периодически думают и едят, время этих действий задается случайным образом.
   - Отображают в консоли результаты своих действий (размышляют, едят).
   - Завершают работу при получении специального уведомления от сервера.

3. **Создание клиентской программы для мониторинга**:
   - Подключается к серверу и получает информацию о текущем состоянии системы.
   - Отображает полученную информацию в реальном времени.
   - Завершает работу при получении специального уведомления от сервера.

4. **Взаимодействие между сервером и клиентами**:
   - Использование сокетов TCP для связи между сервером и клиентами.
   - Сервер прослушивает входящие подключения на заданном порту.
   - Клиенты подключаются к серверу и отправляют запросы.
   - Мониторы подключаются к серверу и получают информацию о текущем состоянии системы.
5. **Завершение программ**:
   - Сервер посылает сообщение "shutdown" всем мониторам и клиентам.
   - Клиенты самостоятельно завершаются при получении от сервера сообщения "shutdown".
   - Мониторы самостоятельно завершаются при получении от сервера сообщения "shutdown".

## Компиляция и запуск программы.

### Используемый компилятор.

Для компиляции программы использовался компилятор Clang.

### Компиляция серверной программы.

```sh 
clang++ -std=c++11 -o server server.cpp -pthread
```
### Компиляция клиентской программы.

```sh
clang++ -std=c++11 -o philosopher philosopher.cpp -pthread
```

### Компиляция монитора.

```sh
clang++ -std=c++11 -o monitor monitor.cpp -pthread
```


### Запуск серверной программы в отдельном терминале.

```sh
./server
```

### Запуск клиентских программ для философов в другом терминале.
#### <server_ip> Выбираем, какой нужен. Я выбирал адрес локальной сети.
```sh
./philosopher <server_ip> 0 &
./philosopher <server_ip> 1 &
./philosopher <server_ip> 2 &
./philosopher <server_ip> 3 &
./philosopher <server_ip> 4 &
```

### Подключение монитора для философов в третьем терминале.
```sh
./monitor <server_ip>
```

## Завершение работы программ.

### Завершение работы сервера.

При нажатии `Ctrl+C` в терминале, где запущен сервер, сервер получает сигнал `SIGINT`, который обрабатывается функцией `shutdown_server`. Эта функция выполняет следующие действия:

1. Устанавливает флаг `running` в `false`, что позволяет выйти из основного цикла сервера.
2. Вызывает функцию `notify_shutdown`, которая отправляет сообщение "shutdown" всем подключенным клиентам и мониторинговым программам.
3. Вызывает `shutdown(server_fd, SHUT_RDWR)` для закрытия сокета сервера и выхода из блокирующего вызова `accept`.

После выхода из основного цикла сервер закрывает сокет и завершает свою работу.

### Действия клиента-философа при завершении.

Каждый клиент-философ в своем цикле ожидает сообщения от сервера. Когда сервер отправляет сообщение "shutdown", клиент-философ выполняет следующие действия:

1. Получает сообщение "shutdown" от сервера.
2. Выводит сообщение "Server shutdown. Philosopher <номер> exiting."
3. Закрывает сокет и завершает выполнение программы с помощью `exit(0)`.

### Действия клиента мониторинга при завершении.

Клиент мониторинга, аналогично клиентам-философам, ожидает сообщения от сервера. Когда сервер отправляет сообщение "shutdown", клиент мониторинга выполняет следующие действия:

1. Получает сообщение "shutdown" от сервера.
2. Выводит сообщение "Server shutdown. Monitor exiting."
3. Закрывает сокет и завершает выполнение программы с помощью `exit(0)`.

#### Примечание
Сервер после получения сигнала о завершении с клавиатуры завершает всех клиентов и мониторы, а самого его приходиться завершать только через 'kill'. Я пытался с этим разобраться, не получилось.

### Место для скриншотов.

![Вывод сервера](OS_IDZ$/screenshots/server.png)

![Вывод клиентов](OS_IDZ$/screenshots/philosopher.png)

![Вывод одного из мониторов](OS_IDZ$/screenshots/monitor.png)
